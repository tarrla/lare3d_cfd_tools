"""
Author
Lucas A. Tarr
ltarr@nso.edu
NSO, Maui, HI

Routines for reading and processing *.cfd files generated by LaRe3D_version2
Note that LaRe version >=3 use a different output format, *.SDF files.

The CFD reader was adapted from original code at
https://raw.githubusercontent.com/mbareford/rs-shock-heating-paper/master/scripts/python/lare3d_cfd.py

The CFD writer was subsequently adpted from the (new) CFD reader by N.Dylan Kee (NSO, now GSFC).

Original LaRe paper by Arber+2001, JCP: 
https://ui.adsabs.harvard.edu/abs/2001JCoPh.171..151A/abstract

Most recent academic website:
https://warwick.ac.uk/fac/sci/physics/research/cfsa/people/tda/larexd/

Github repository (version 4 of LaRe, also using *.SDF files)
https://github.com/Warwick-Plasma/Lare3d 


LAT: I plan to release (some version of) this file when I publish my next paper describing data
driven simulations using LaRe, Tarr+2024 ApJS 270, 30 
    DOI: 10.3847/1538-4365/ad0e0c
    ADS: https://ui.adsabs.harvard.edu/abs/2024ApJS..270...30T/abstract

Also plan to change this from functions to an actual module (eventually).
"""

import struct
import array
import numpy as np
import warnings

class ValidationError(Exception):
    pass

class ValidationWarning(UserWarning):
    pass

def get_index(c_val, grid):
    c_i = np.argmin(np.abs(grid-c_val) )
    return int(c_i)

def read_lare_cfd3d(filename, verbose=False, **kwargs):
    """Read in a lare cfd file and return it as a dictionary.
    
    This method loads a lare cfd file and returns selected variables as a numpy structure.  
    A subvolume of the variables can be loaded using the **kwargs xrange, ixrange, etc, where
    the first variety (*range) selects the subvolume using data units and the second (i*range)
    uses pixel units.  If both are present, pixel units supercedes data units.

    A subset of the variables can be selected using the 'getfields' **kwargs, where getfields
    is set to a tuple of variable names.  The grid by itself and the available fields can be 
    returned by passing 'grid' to getfields.
    
    Adapted from the lare3d_cfd.py script written by M.R. Bareford:
    https://github.com/mbareford/rs-shock-heating-paper

    See Bareford and Hood 2015, PTRS-A 373, "Shock heating in numerical simulations of kink-unstable coronal loops"
    https://ui.adsabs.harvard.edu/abs/2015RSPTA.37340266B/abstract
    http://rsta.royalsocietypublishing.org/content/373/2042/20140266


    The current version of ths *.cfd reader was developed largely in support of the following work:
    See also Tarr+2024 ApJS 270, 30 , "Simulating the Photospheric to Coronal Plasma Using Magnetohydrodynamic Characteristics. I. Data-driven Boundary Conditions" 
    DOI: 10.3847/1538-4365/ad0e0c
    ADS: https://ui.adsabs.harvard.edu/abs/2024ApJS..270...30T/abstract

    Examples
    --------
    Load the density and velocity variables:
    >>> dat = read_lare_cfd3d('./Data/000000.cfd',getfields=('rho','vz'))
    
    Load only the grid.
    >>> dat = read_lare_cfd3d('./Data/000000.cfd',getfields=('grid',))
    
    Load everything for a within a range of -0.2<z<0.5
    >>> dat = read_lare_cfd3d('./Data/000000.cfd', zrange=(0.2,0.5))

    Load magnetic field data near the center of a 512^3 box

    >>> dat = read_lare_cfd3d('./Data/000000.cfd', getfields=('Bx','By','Bz'),
              izrange=(192,320), iyrange=(192,320),ixrange=(192,320))

    **kwargs:
    ----------
    getfields : tuple
        Return on the subset of selected variables: getfields =('var1', 'var2',).
        Arrays are ordered in standard python order: var[0:NZ-1,0:NY-1,0:NX-1]
    
    xrange : array_like
        Two element array [xmin,xmax] with xmin<xmax describing the x-domain to extract in terms of data units

    yrange : array_like
        Two element array [ymin,ymax] with ymin<ymax describing the y-domain to extract in terms of data units

    zrange : array_like
        Two element array [zmin,zmax] with zmin<zmax describing the z-domain to extract in terms of data units

    NOTE: if both index-based and unit-based subsamples are requested, the index-based takes precedence.

    ixrange : array_like
        Two element array [ixmin,ixmax] with ixmin<ixmax describing the x-domain to extract in terms of cell indices

    iyrange : array_like
        Two element array [iymin,iymax] with iymin<iymax describing the y-domain to extract in terms of cell indices

    izrange : array_like
        Two element array [izmin,izmax] with izmin<izmax describing the z-domain to extract in terms of cell indices

    Returns
    -------
    dat : dict
        A dictionary that describes the grid and the returned data variables.
        The orientation of the data fields are typical of python (not fortran or IDL),
        so for a standard solar physics simulation with x,y the horizontal directions
        and z the gravitational direction, with iz=0 the bottom and iz=NZ the top,
        the ordering of the array is `dat['rho'][iz, iy, ix]` and `dat['rho'][10]` 
        selects the 11th constant-z plane of cells from the bottom of the grid.

        The sizes are returned according to the original LARE CFD 
        format, so all variables have the same size.  But because of the staggered grid, 
        vertex variables within the domain have one more element than cell centered
        variables in each direction, and face centered variables have one
        more element in their normal direction compared to cell centered 
        variables.  Therefore, the loaded arrays for cell centered and face variables 
        contain elements from outside the numerical domain (e.g., in ghost cells).  If 
        the full data range is returned then the first "extra" variable is the first 
        ghost value.  E.g., `dat['rho'][1:,1:,1:]` would contain the full numerical 
        domain, while `dat['rho'][0,:,:]` would be the z_min ghost cell values.
    """

    char_size = 1
    int_size = 4
    long_size = 8
    dbl_size = 8
    hdr_tag_len = 3
    if 'getfields' in kwargs:
        if not isinstance(kwargs['getfields'],tuple):
            print('Getfields must be a tuple.  To load a single variable named VAR, use getfields=(\'VAR\',)')
            return
        
        print('trying to load variables:', kwargs['getfields'])
        fields = list((a.lower() for a in kwargs['getfields']))
    else: fields = ['all']
    
    cfd = open(filename, 'rb')
    # process file header
    #################################################################
    hdr_tag = cfd.read(hdr_tag_len)
    hdr_size = struct.unpack_from('i', cfd.read(int_size))[0]                
    blk_hdr_size = struct.unpack_from('i', cfd.read(int_size))[0]
    cfd_ver = struct.unpack_from('i', cfd.read(int_size))[0]
    cfd_rev = struct.unpack_from('i', cfd.read(int_size))[0]
    max_str_len = struct.unpack_from('i', cfd.read(int_size))[0]
    nblocks = struct.unpack_from('i', cfd.read(int_size))[0]

    if verbose:
        print( 'Header tag: ', hdr_tag)
        print( 'Header size: ', hdr_size)
        print( 'Block header size: ', blk_hdr_size)
        print( 'CFD version: ', cfd_ver)
        print( 'CFD revision: ', cfd_rev)
        print( 'Max str len: ', max_str_len)
        print( 'nblocks: ', nblocks    )
        print(' ')


    # process first block (time)
    ######################################################################
    tm_blk_name = cfd.read(max_str_len)
    tm_blk_class = cfd.read(max_str_len)
    tm_blk_type = struct.unpack_from('i', cfd.read(int_size))[0]
    tm_blk_len = struct.unpack_from('l', cfd.read(long_size))[0]
    tm_blk_meta_len = struct.unpack_from('l', cfd.read(long_size))[0]
    
    step = struct.unpack_from('i', cfd.read(int_size))[0]
    time = struct.unpack_from('d', cfd.read(dbl_size))[0]

    if verbose:
        print( 'Time block name: ', tm_blk_name.decode('utf8'))
        print( 'Time block class: ', tm_blk_class.decode('utf8'))
        print( 'Time block type: ', tm_blk_type)
        print( 'Time block len: ', tm_blk_len)
        print( 'Time block meta len: ', tm_blk_meta_len)
        print( 'Step: ', step)
        print( 'Time: ', time)
    ######################################################################
    
    
    # process second block (grid)
    ##############################################################################################################
    grd_blk_name = cfd.read(max_str_len)
    grd_blk_class = cfd.read(max_str_len)
    grd_blk_type = struct.unpack_from('i', cfd.read(int_size))[0]
    grd_blk_len = struct.unpack_from('l', cfd.read(long_size))[0]
    grd_blk_meta_len = struct.unpack_from('l', cfd.read(long_size))[0]
    
    grd_type = struct.unpack_from('i', cfd.read(int_size))[0]
    grd_dim = struct.unpack_from('i', cfd.read(int_size))[0]
    grd_field_size = struct.unpack_from('i', cfd.read(int_size))[0]    
    grd_nx = struct.unpack_from('i', cfd.read(int_size))[0]
    grd_ny = struct.unpack_from('i', cfd.read(int_size))[0]
    grd_nz = struct.unpack_from('i', cfd.read(int_size))[0]    
    x_min = struct.unpack_from('d', cfd.read(dbl_size))[0]
    x_max = struct.unpack_from('d', cfd.read(dbl_size))[0]
    y_min = struct.unpack_from('d', cfd.read(dbl_size))[0]
    y_max = struct.unpack_from('d', cfd.read(dbl_size))[0]
    z_min = struct.unpack_from('d', cfd.read(dbl_size))[0]
    z_max = struct.unpack_from('d', cfd.read(dbl_size))[0]
    
    x = struct.unpack_from(str(eval('grd_nx')) + 'd', cfd.read(dbl_size*grd_nx))
    y = struct.unpack_from(str(eval('grd_ny')) + 'd', cfd.read(dbl_size*grd_ny))
    z = struct.unpack_from(str(eval('grd_nz')) + 'd', cfd.read(dbl_size*grd_nz))
    
    x = np.array(x)
    y = np.array(y)
    z = np.array(z)

    x_min_i = 0
    x_max_i=grd_nx-1
    y_min_i = 0
    y_max_i=grd_ny-1
    z_min_i = 0
    z_max_i=grd_nz-1

    grd_blk_meta_len = grd_blk_len + (grd_nx + grd_ny +grd_nz)*grd_field_size


    subsample_x = False
    subsample_y = False
    subsample_z = False
    ## Check for subsample requests in each dimension:
    if 'xrange' in kwargs:
        if not len(kwargs['xrange'])==2:
            raise ValidationError('xrange must have two elements, min and max')

        else:
            if verbose: print('Found subsample request in the X direction')
            x_min = kwargs['xrange'][0]
            x_max = kwargs['xrange'][1]
        if (x_max < x_min):
            raise ValidationError('Second element of xrange must be larger than first element.\n Instead found xrange=[{:6.3e}, {:6.3e}]'.format(x_min,x_max))

        if (x_min < x[0] or x_max > x[-1]):
            raise ValidationError("Requested xrange is greater than computional domain in x direction. REQUESTED: X[{:3.3e}:{:3.3e}], AVAILABLE: X[{:3.3e}:{:3.3e}]".format(x_min,x_max,x[0],x[-1]))

        subsample_x=True
        x_min_i = get_index(x_min, x)
        x_max_i = get_index(x_max, x)

        
    if 'yrange' in kwargs:
        if not len(kwargs['yrange'])==2:
            raise ValidationError('yrange must have two elements, min and max')
        else:
            if verbose: print('Found subsample request in the Y direction')
            y_min = kwargs['yrange'][0]
            y_max = kwargs['yrange'][1]

        if (y_max < y_min):
            raise ValidationError('Second element of yrange must be larger than first element.\n Instead found yrange=[{:6.3e}, {:6.3e}]'.format(y_min,y_max))

        if (y_min < y[0] or y_max > y[-1]):
            raise ValidationError("Requested yrange is greater than computional domain in y direction. REQUESTED: Y[{:3.3e}:{:3.3e}], AVAILABLE: Y[{:3.3e}:{:3.3e}]".format(y_min,y_max,y[0],y[-1]))

        subsample_y=True
        y_min_i = get_index(y_min, y)
        y_max_i = get_index(y_max, y)

    if 'zrange' in kwargs:
        if not len(kwargs['zrange'])==2:
            raise ValidationError('zrange must have two elements, min and max')

        else:
            if verbose: print('Found subsample request in the Z direction')
            z_min = kwargs['zrange'][0]
            z_max = kwargs['zrange'][1]
        if (z_max < z_min):
            raise ValidationError('Second element of zrange must be larger than first element.\n Instead found zrange=[{:6.3e}, {:6.3e}]'.format(z_min,z_max))
        
        if (z_min < z[0] or z_max > z[-1]):
            raise ValidationError("Requested zrange is greater than computional domain in z direction. REQUESTED: Z[{:3.3e}:{:3.3e}], AVAILABLE: Z[{:3.3e}:{:3.3e}]".format(z_min,z_max,z[0],z[-1]))
        subsample_z=True
        z_min_i = get_index(z_min, z)
        z_max_i = get_index(z_max, z)
        


    ## Check for index-based subsample requests in each dimension:
    if 'ixrange' in kwargs:
        if 'xrange' in kwargs:
            warnings.warn("ixrange called when xrange is also present.  Defaulting to ixrange.",ValidationWarning)

        if not len(kwargs['ixrange'])==2:
            raise ValidationError('ixrange must have two elements, min and max')

        else:
            if verbose: print('Found subsample request in the X direction')
            x_min_i = kwargs['ixrange'][0]
            x_max_i = kwargs['ixrange'][1]

        if (x_max_i < x_min_i):
            raise ValidationError('Second element of ixrange must be larger than first element.\n Instead found ixrange=[{:04d}, {:04d}]'.format(x_min_i,x_max_i))

        if (x_min_i < 0 or (grd_nx-1 < x_max_i)):
            raise ValidationError("Requested ixrange is greater than computional domain in x direction.  REQUESTED: [{:4d}, {:4d}]  AVAILABLE:[{:4d}, {:4d}]".format(x_min_i,x_max_i,0,grd_nx-1))
        subsample_x=True
        x_min = x[x_min_i]
        x_max = x[x_max_i]

    if 'iyrange' in kwargs:
        if 'yrange' in kwargs:
            warnings.warn("iyrange called when yrange is also present.  Defaulting to iyrange.",ValidationWarning)

        if not len(kwargs['iyrange'])==2:
            raise ValidationError('iyrange must have two elements, min and max')

        else:
            if verbose: print('Found subsample request in the X direction')
            y_min_i = kwargs['iyrange'][0]
            y_max_i = kwargs['iyrange'][1]

        if (y_max_i < y_min_i):
            raise ValidationError('Second element of iyrange must be larger than first element.\n Instead found iyrange=[{:04d}, {:04d}]'.format(y_min_i,y_max_i))

        if (y_min_i < 0 or (grd_ny-1 < y_max_i)):
            raise ValidationError("Requested iyrange is greater than computional domain in y direction: REQUESTED: [{:4d}, {:4d}]  AVAILABLE:[{:4d}, {:4d}]".format(y_min_i,y_max_i,0,grd_ny-1))
        subsample_y=True
        x_min = y[y_min_i]
        x_max = y[y_max_i]


    if 'izrange' in kwargs:
        if 'zrange' in kwargs:
            warnings.warn("izrange called when zrange is also present.  Defaulting to izrange.",ValidationWarning)

        if not len(kwargs['izrange'])==2:
            raise ValidationError('izrange must have two elements, min and max')

        else:
            if verbose: print('Found subsample request in the X direction')
            z_min_i = kwargs['izrange'][0]
            z_max_i = kwargs['izrange'][1]

        if (z_max_i < z_min_i):
            raise ValidationError('Second element of izrange must be larger than first element.\n Instead found izrange=[{:04d}, {:04d}]'.format(z_min_i,z_max_i))

        if (z_min_i < 0 or (grd_nz-1 < z_max_i)):
            raise ValidationError("Requested izrange is greater than computional domain in z direction.  REQUESTED: [{:4d}, {:4d}]  AVAILABLE:[{:4d}, {:4d}]".format(z_min_i,z_max_i,0,grd_nz-1))
        subsample_z=True
        z_min = z[z_min_i]
        z_max = z[z_max_i]




    if verbose:
        print('Grid type: ', grd_type)
        print('Grid dim: ', grd_dim)
        print('Grid field size: ', grd_field_size    )
        print('Grid nx: ', grd_nx)
        print('Grid ny: ', grd_ny)
        print('Grid nz: ', grd_nz)
        print('Grid x min: ', grd_x_min)
        print('Grid x max: ', grd_x_max)
        print('Grid y min: ', grd_y_min)
        print('Grid y max: ', grd_y_max)
        print('Grid z min: ', grd_z_min)
        print('Grid z max: ', grd_z_max)


    x = x[x_min_i:x_max_i+1]
    y = y[y_min_i:y_max_i+1]
    z = z[z_min_i:z_max_i+1]
    nx = len(x)
    ny = len(y)
    nz = len(z)
    xc = (x[1:]+x[0:-1])/2
    yc = (y[1:]+y[0:-1])/2
    zc = (z[1:]+z[0:-1])/2    

    if verbose: print('Subsample in each dimension:\n X: {:s}\n Y: {:s}\n Z: {:s}'.format(str(subsample_x),str(subsample_y), str(subsample_z)))


    ### now start unpacking the data
    field_names = ()
    allblkdata = {}
    
    for i in range(2, nblocks):
        current_pos=cfd.tell()
        var_blk_name = cfd.read(max_str_len).decode('utf8').rstrip()[:-1].lower()
        var_blk_class = cfd.read(max_str_len).decode('utf8').rstrip()[:-1]
        var_blk_type = struct.unpack_from('i', cfd.read(int_size))[0]
        var_blk_meta_len = struct.unpack_from('l', cfd.read(long_size))[0]
        var_blk_len = struct.unpack_from('l', cfd.read(long_size))[0]
        
        var_type = struct.unpack_from('i', cfd.read(int_size))[0]
        var_dim = struct.unpack_from('i', cfd.read(int_size))[0]
        var_field_size = struct.unpack_from('i', cfd.read(int_size))[0]
        
        
        var_nx = struct.unpack_from('i', cfd.read(int_size))[0]
        var_ny = struct.unpack_from('i', cfd.read(int_size))[0]
        var_nz = struct.unpack_from('i', cfd.read(int_size))[0]

        var_blk_total_len = 4*max_str_len + 7*int_size + 2*long_size + 5*dbl_size + var_field_size*var_nx*var_ny*var_nz
        data_location = cfd.tell()

        sub_ny = y_max_i-y_min_i+1
        sub_nx = x_max_i-x_min_i+1
        sub_nz = z_max_i-z_min_i+1
        sub_dims=[sub_nx,sub_ny,sub_nz]
        
        field_names +=(var_blk_name,)
        if ((var_blk_name in fields) or ('all' in fields)):
            # read data for this variable
            var_stag_x = struct.unpack_from('d', cfd.read(dbl_size))[0]
            var_stag_y = struct.unpack_from('d', cfd.read(dbl_size))[0]
            var_stag_z = struct.unpack_from('d', cfd.read(dbl_size))[0]

            var_min = struct.unpack_from('d', cfd.read(dbl_size))[0]
            var_max = struct.unpack_from('d', cfd.read(dbl_size))[0]    
            var_mesh_name = cfd.read(max_str_len)
            var_mesh_class = cfd.read(max_str_len)

            # go though subsampling cases:
            if((not subsample_z and not subsample_y and not subsample_x) or var_blk_name=='ls'):
                # No subsampling: Get entire block
                #fmt = str(var_nx*var_ny*var_nz)+'d'
                #var_data = np.array(struct.unpack_from(fmt, cfd.read(var_field_size*(var_nx*var_ny*var_nz))))
                sz = var_nx*var_ny*var_nz
                var_data = np.frombuffer(cfd.read(var_field_size*sz),dtype=np.double,count=sz )

            elif(subsample_z and not subsample_y and not subsample_x):
                # Extract a slice in z, over the full range in x and y
                #  (Data is contiguous)
                cfd.seek(z_min_i*var_nx*var_ny*var_field_size, 1)
                #fmt = str((z_max_i-z_min_i+1)*var_nx*var_ny)+'d'
                #var_data = np.array(struct.unpack_from(fmt, cfd.read(var_field_size*((z_max_i-z_min_i+1)*var_nx*var_ny))))
                sz = (z_max_i-z_min_i+1)*var_nx*var_ny
                var_data = np.frombuffer(cfd.read(var_field_size*sz),dtype=np.double,count=sz )
                # skip to end
                cfd.seek(current_pos+var_blk_total_len)
                var_nz = z_max_i-z_min_i+1
                var_min = min(var_data)
                var_max = max(var_data)
                var_blk_meta_len = var_blk_len + (var_nx*var_ny*var_nz)*var_field_size

            elif(subsample_y or subsample_x):
                # Data is not contiguous:
                # Cycle through iy and skip the parts in ix we don't want
                #
                # Steps: 
                #    1) Read the x-y plane subregion into var_data  
                #    2) Append later slices to that var_data
                #    3) Step to the end of the data block
                selection_offset=0

                fmt = str(sub_dims[0])+'d'
                var_data = np.zeros(np.product(sub_dims))
                # STEP 1: First iz slice
                # Get to the first z-data element to read
                cfd.seek((z_min_i*var_nx*var_ny+y_min_i*var_nx+x_min_i)*var_field_size, 1)

                # Read first set of ix data
                x_data_len = x_max_i-x_min_i+1
                x_to_end = var_nx-x_max_i-1
                # fmt = str(x_data_len) + 'd'
                # var_data[0:x_data_len] = np.array(struct.unpack_from(fmt, cfd.read(var_field_size*x_data_len)))
                var_data[0:x_data_len] =  np.frombuffer(cfd.read(var_field_size*x_data_len),dtype=np.double,count=x_data_len)
                selection_offset +=x_data_len
                # Skip to end of current iy index (eg, end byte data location y_min_i*NX)
                cfd.seek(x_to_end*var_field_size, 1)
                ## Repeat: cycle though each row in iy
                for iy in range(y_min_i+1, y_max_i+1):
                    cfd.seek(x_min_i*var_field_size, 1)
                    #var_data[selection_offset:selection_offset+sub_dims[0]] =np.array(struct.unpack_from(fmt, cfd.read(var_field_size*x_data_len)))
                    var_data[selection_offset:selection_offset+sub_dims[0]] = np.frombuffer(cfd.read(var_field_size*x_data_len),dtype=np.double,count=x_data_len)
                    selection_offset +=x_data_len
                    # Skip to position NX in row iy
                    cfd.seek((var_nx-x_max_i-1)*var_field_size, 1)
                # After the last iy, skip to the end of the current slice in iz
                cfd.seek((var_ny-y_max_i-1)*var_nx*var_field_size, 1)

                # STEP 2: Repeat the process for all z
                for iz in range(z_min_i+1, z_max_i+1):
                    # Get to the first data element to read in this z slice
                    cfd.seek((y_min_i*var_nx)*var_field_size, 1)
                    for iy in range(y_min_i, y_max_i+1):
                        cfd.seek(x_min_i*var_field_size, 1)
                        #var_data[selection_offset:selection_offset+sub_dims[0]] =np.array(struct.unpack_from(fmt, cfd.read(var_field_size*x_data_len)))
                        var_data[selection_offset:selection_offset+sub_dims[0]] =np.frombuffer(cfd.read(var_field_size*x_data_len),dtype=np.double,count=x_data_len)
                        selection_offset +=x_data_len
                        # Skip to position NX in row iy
                        cfd.seek((var_nx-x_max_i-1)*var_field_size, 1)
                    # Skip to position NX*NY in slice iz
                    cfd.seek((var_ny-y_max_i-1)*var_nx*var_field_size, 1)

                # STEP 3: Finalize by skipping to end of current data block in iz
                cfd.seek((var_nz-z_max_i-1)*var_nx*var_ny*var_field_size, 1)

            # end if..elif...elif
            if (not var_blk_name == 'ls'):
                var_nz = z_max_i-z_min_i+1
                var_ny = y_max_i-y_min_i+1
                var_nx = x_max_i-x_min_i+1
                
            allblkdata[var_blk_name]=np.reshape(var_data,(var_nz,var_ny, var_nx))
        else:
            ## skip this variable
            cfd.seek(current_pos+var_blk_total_len)


    ## expand the allblkdata to include all the information we want:
    allblkdata['filename']=filename
    allblkdata['time']=time
    allblkdata['step']=step
    allblkdata['nx']=nx
    allblkdata['ny']=ny
    allblkdata['nz']=nz
    allblkdata['x']=x
    allblkdata['y']=y
    allblkdata['z']=z
    allblkdata['xc']=xc
    allblkdata['yc']=yc
    allblkdata['zc']=zc

    if 'grid' in fields:
        allblkdata['field_names']=field_names

    cfd.close()
    return allblkdata
    ## END OF CFD READ FUNCTION


def write_lare_cfd3d(filename, allblkdata, nvars, verbose=False, **kwargs):
    '''Using data in a dictionary (same format as read_lare_cfd3d), write a lare cfd file.
    
    (Author: N.D.Kee, NSO, Maui, HI, dkee@nso.edu)
    The routine takes a filename and 'allblkdata' in the format generated by read_lare_cfd3d.
    The **kwargs from read_lare_cfd3d are no longer relevant here, as the grid can be
    assumed to be the full range we wish to write, and we are passing how many variables to write.

    TO DO:
    ------
    This code could likely be substantially sped up by switching from struct.pack() to np.tobytes(), 
    as was done to the read_lare_cfd3d() function using np.frombuffer().

    Example
    --------
    Load the density and velocity variables with read_lare_cfd3d, and immediately return them to a restart file:
    >>> dat = read_lare_cfd3d('./Data/000000.cfd',getfields=('all',))
    >>> write_lare_cfd3d('./restart_dir/000000.cfd',dat,n)
    where n is the number of variables to be written
    
    Note that extra manipulation of the data can of course occur between the read and write including expanding
    or truncating the size of dat so long as dat retains the appropriate relation of grid and vars regarding
    size, dimensions, etc. and
    
    Input Data (as per read_lare_cfd3d):
    -------------------------------------
        dat : dict
        A dictionary that describes the grid and the full set of data variables.
        Note that the sizes must be passed according to the original LARE CFD
        format, so all variables have the same size.  But in reality, the
        vertex variables have one more element than cell centered
        variables in each direction, and face centered variables have one
        more element in their normal direction compared to cell centered
        variables.  Therefore, the cell centered and face variable arrays
        contain elements from outside the numerical domain.  If the full data
        range is returned then the first "extra" variable is the first ghost value.
        E.g., `dat['rho'][1:,1:,1:]` would contain the full numerical domain, while
        `dat['rho'][0,:,:]` would be the z_min ghost cell values
        
        nvars : int
        The number of variables that will be written to the file. This is used to
        compute the number of blocks for the header and to set the limits of the
        final loop
    
    Returns
    -------
    None
    '''


    
    cfd = open(filename, 'wb')
    # process file header
    #################################################################
    hdr_tag = b'CFD'
    hdr_size = 27
    blk_hdr_size = 100
    cfd_ver = 1
    cfd_rev = 0
    max_str_len = 40
    nblocks = 2 + nvars

    cfd.write(hdr_tag)
    cfd.write(struct.pack('i',hdr_size))
    cfd.write(struct.pack('i',blk_hdr_size))
    cfd.write(struct.pack('i',cfd_ver))
    cfd.write(struct.pack('i',cfd_rev))
    cfd.write(struct.pack('i',max_str_len))
    cfd.write(struct.pack('i',nblocks))

    if verbose:
        print( 'Header tag: ', hdr_tag)
        print( 'Header size: ', hdr_size)
        print( 'Block header size: ', blk_hdr_size)
        print( 'CFD version: ', cfd_ver)
        print( 'CFD revision: ', cfd_rev)
        print( 'Max str len: ', max_str_len)
        print( 'nblocks: ', nblocks    )
        print(' ')


    
    # process first block (time)
    ######################################################################
    tm_blk_name = "Snapshot"
    tm_blk_class = "Snapshot"
    tm_blk_type = 3
    tm_blk_len = 12
    tm_blk_meta_len = 12
    step = allblkdata['step']
    time = allblkdata['time']

    cfd.write((tm_blk_name.encode('utf8')+'\x00'.encode('utf8')).ljust(max_str_len))
    cfd.write((tm_blk_class.encode('utf8')+'\x00'.encode('utf8')).ljust(max_str_len))
    cfd.write(struct.pack('i',tm_blk_type))
    cfd.write(struct.pack('l',tm_blk_len))
    cfd.write(struct.pack('l',tm_blk_meta_len))
    cfd.write(struct.pack('i',step))
    cfd.write(struct.pack('d',time))

    if verbose:
        print( 'Time block name: ', tm_blk_name)
        print( 'Time block class: ', tm_blk_class)
        print( 'Time block type: ', tm_blk_type)
        print( 'Time block len: ', tm_blk_len)
        print( 'Time block meta len: ', tm_blk_meta_len)
        print( 'Step: ', step)
        print( 'Time: ', time)
        print( ' ')
    ######################################################################
    
    
    # process second block (grid)
    ##############################################################################################################
    grd_blk_name = "Grid"
    grd_blk_class = "Grid"
    grd_blk_type = 1
    grd_blk_len = 72
    grd_field_size = 8
    
    grd_nx = allblkdata['nx']
    grd_ny = allblkdata['ny']
    grd_nz = allblkdata['nz']
    
    grd_blk_meta_len = grd_blk_len + (grd_nx + grd_ny +grd_nz)*grd_field_size
    
    cfd.write((grd_blk_name.encode('utf8')+'\x00'.encode('utf8')).ljust(max_str_len))
    cfd.write((grd_blk_class.encode('utf8')+'\x00'.encode('utf8')).ljust(max_str_len))
    cfd.write(struct.pack('i',grd_blk_type))
    cfd.write(struct.pack('l',grd_blk_len))
    cfd.write(struct.pack('l',grd_blk_meta_len))
    
    grd_type = 0
    grd_dim = 3
    
    cfd.write(struct.pack('i',grd_type))
    cfd.write(struct.pack('i',grd_dim))
    cfd.write(struct.pack('i',grd_field_size))
    cfd.write(struct.pack('i',grd_nx))
    cfd.write(struct.pack('i',grd_ny))
    cfd.write(struct.pack('i',grd_nz))
    cfd.write(struct.pack('d',allblkdata['x'][0]))
    cfd.write(struct.pack('d',allblkdata['x'][-1]))
    cfd.write(struct.pack('d',allblkdata['y'][0]))
    cfd.write(struct.pack('d',allblkdata['y'][-1]))
    cfd.write(struct.pack('d',allblkdata['z'][0]))
    cfd.write(struct.pack('d',allblkdata['z'][-1]))
    
    for i in range(grd_nx):
      cfd.write(struct.pack('d',allblkdata['x'][i]))
    for j in range(grd_ny):
      cfd.write(struct.pack('d',allblkdata['y'][j]))
    for k in range(grd_nz):
      cfd.write(struct.pack('d',allblkdata['z'][k]))
#    cfd.write(struct.pack(str(eval('grd_nx')) + 'd',allblkdata['x']))
#    cfd.write(struct.pack(str(eval('grd_ny')) + 'd',allblkdata['y']))
#    cfd.write(struct.pack(str(eval('grd_nz')) + 'd',allblkdata['z']))
   
    if verbose:
        print('Grid type: ', grd_type)
        print('Grid dim: ', grd_dim)
        print('Grid field size: ', grd_field_size    )
        print('Grid nx: ', grd_nx)
        print('Grid ny: ', grd_ny)
        print('Grid nz: ', grd_nz)
        print(' ')


    
    for i in range(nvars):
        var_blk_name = list(allblkdata.keys())[i]
        if var_blk_name.startswith('b'):
            var_blk_class = "Magnetic_Field"
        elif var_blk_name.startswith('v'):
            var_blk_class = "Velocity"
        else:
            var_blk_class = "Fluid"
        
        var_blk_type = 2
        var_blk_meta_len = 144
        var_blk_len = var_blk_meta_len + allblkdata['nx']*allblkdata['ny']*allblkdata['nz']*8
        
        cfd.write(((var_blk_name.capitalize()).encode('utf8')+'\x00'.encode('utf8')).ljust(max_str_len))
        cfd.write((var_blk_class.encode('utf8')+'\x00'.encode('utf8')).ljust(max_str_len))
        cfd.write(struct.pack('i',var_blk_type))
        cfd.write(struct.pack('l',var_blk_meta_len))
        cfd.write(struct.pack('l',var_blk_len))

        var_type = 0
        var_dim = 3
        var_field_size = 8
        
        cfd.write(struct.pack('i',var_type))
        cfd.write(struct.pack('i',var_dim))
        cfd.write(struct.pack('i',var_field_size))
        
        var_nx = allblkdata['nx']
        var_ny = allblkdata['ny']
        var_nz = allblkdata['nz']
        
        cfd.write(struct.pack('i',var_nx))
        cfd.write(struct.pack('i',var_ny))
        cfd.write(struct.pack('i',var_nz))
        
        var_stag_x = 0.0
        var_stag_y = 0.0
        var_stag_z = 0.0
        
        cfd.write(struct.pack('d',var_stag_x))
        cfd.write(struct.pack('d',var_stag_y))
        cfd.write(struct.pack('d',var_stag_z))
        
        var_min = np.min(allblkdata[var_blk_name])
        var_max = np.max(allblkdata[var_blk_name])
        var_mesh_name = "Grid"
        var_mesh_class = "Grid"
        
        cfd.write(struct.pack('d',var_min))
        cfd.write(struct.pack('d',var_max))
        cfd.write((var_mesh_name.encode('utf8')+'\x00'.encode('utf8')).ljust(max_str_len))
        cfd.write((var_mesh_class.encode('utf8')+'\x00'.encode('utf8')).ljust(max_str_len))

        cfd.write(allblkdata[var_blk_name].flatten().tobytes() )
        
        if verbose:
            print('Var block name: ',var_blk_name)
            print('Var block class: ',var_blk_class)
            '''
            print('Var block type: ',var_blk_type)
            print('Var block meta len: ',var_blk_meta_len)
            print('Var block len: ',var_blk_len)
            print('Var type: ',var_type)
            print('Var dim: ',var_dim)
            print('Var field size: ',var_field_size)
            print('Var nx: ',var_nx)
            print('Var ny: ',var_ny)
            print('Var nz: ',var_nz)
            print('Var stag x: ',var_stag_x)
            print('Var stag y: ',var_stag_y)
            print('Var stag z: ',var_stag_z)
            '''
            print('Var min: ',var_min)
            print('Var max: ',var_max)
            '''
            print('Var mesh name: ',var_mesh_name)
            print('Var mesh class: ',var_mesh_class)
            '''
            print(' ')

    cfd.close()
    ## END OF CFD WRITE FUNCTION


def get_ptot(dat):
    '''Total pressure at cell centers

    P_tot = P_gas + P_mag

    Input
    -----
    dat : dict
        A dictionary containing Lare version 2 (cfd) data.  Array dimensions [NZ,NY,NX]
    
    Returns
    -------
    ptot : numpy.ndarray
        An array containing the total pressure defined at cell centers [NZ-1,NY-1,NX-1]

    Assumptions
    -------
    If the ratio of specific heats gamma is not defined in the input dictionary
    it is assumed to ahve a value of 5./3.
    '''
    
    bzc = (np.roll(dat['bz'],-1, axis=0)+dat['bz'])[:-1,1:,1:]/2 
    byc = (np.roll(dat['by'],-1, axis=1)+dat['by'])[1:,:-1,1:]/2 
    bxc = (np.roll(dat['bx'],-1, axis=2)+dat['bx'])[1:,1:,:-1]/2 
    btot_sqrd = (bxc**2+byc**2+bzc**2)
    if 'gamma' in dat.keys():
        gamma = dat['gamma']
    else :
        gamma = 5./3 # default
        
    return (gamma-1)*dat['energy'][1:,1:,1:]*dat['rho'][1:,1:,1:]+btot_sqrd/2


def get_b_central(dat):
    '''
    average b to cell center from cell faces.

    INPUT
    -----
    :dat['bx','by','bz']: array dimensions [NZ,NY,NX]

    OUTPUT
    ------
    :bxc, byc, bzc: array dimensions [NZ-1,NY-1,NX-1]
    '''

    bzc = (np.roll(dat['bz'],-1, axis=0)+dat['bz'])[:-1,1:,1:]/2 
    byc = (np.roll(dat['by'],-1, axis=1)+dat['by'])[1:,:-1,1:]/2 
    bxc = (np.roll(dat['bx'],-1, axis=2)+dat['bx'])[1:,1:,:-1]/2 
    return bxc,byc,bzc

def get_v_central(dat):
    '''
    Average v from cell vertex to cell center.  Assumes uniform spacing in x,y,z
    returns: vxc, vyc, vzc
    '''

    vxc = (dat['vx'] \
           + np.roll(dat['vx'],-1, axis=1) \
           + np.roll(dat['vx'],-1, axis=2) \
           + np.roll(dat['vx'],-1, axis=(1,2)) \
           + np.roll(dat['vx'],-1, axis=0) \
           + np.roll(dat['vx'],-1, axis=(0,1)) \
           + np.roll(dat['vx'],-1, axis=(0,2)) \
           + np.roll(dat['vx'],-1, axis=(0,1,2)))[:-1,:-1,:-1]/8
    vyc = (dat['vy'] \
           + np.roll(dat['vy'],-1, axis=1) \
           + np.roll(dat['vy'],-1, axis=2) \
           + np.roll(dat['vy'],-1, axis=(1,2)) \
           + np.roll(dat['vy'],-1, axis=0) \
           + np.roll(dat['vy'],-1, axis=(0,1)) \
           + np.roll(dat['vy'],-1, axis=(0,2)) \
           + np.roll(dat['vy'],-1, axis=(0,1,2)))[:-1,:-1,:-1]/8
    vzc = (dat['vz'] \
           + np.roll(dat['vz'],-1, axis=1) \
           + np.roll(dat['vz'],-1, axis=2) \
           + np.roll(dat['vz'],-1, axis=(1,2)) \
           + np.roll(dat['vz'],-1, axis=0) \
           + np.roll(dat['vz'],-1, axis=(0,1)) \
           + np.roll(dat['vz'],-1, axis=(0,2)) \
           + np.roll(dat['vz'],-1, axis=(0,1,2)))[:-1,:-1,:-1]/8
    return vxc,vyc,vzc


def get_beta(dat):
    '''
    Return the value of plasma beta evaluated at cell centers.
    
    beta = P_gas/P_mag = nKT/(B^2/2mu0_si) 
    --> Lare --> 2rhoT/B^2 ---> 2rho(gamma-1)*energy/B^2

    CAUTION: includes some funky limits on the value!!
    '''

    bzc = (np.roll(dat['bz'],-1, axis=0)+dat['bz'])[:-1,1:,1:]/2 
    byc = (np.roll(dat['by'],-1, axis=1)+dat['by'])[1:,:-1,1:]/2 
    bxc = (np.roll(dat['bx'],-1, axis=2)+dat['bx'])[1:,1:,:-1]/2 
    btot_sqrd = (bxc**2+byc**2+bzc**2)
    if 'gamma' in dat.keys():
        gamma = dat['gamma']
    else :
        gamma = 5./3 # default
        
    return np.where(btot_sqrd >1e-10,2*(gamma-1)*dat['rho'][1:,1:,1:]*dat['energy'][1:,1:,1:]/btot_sqrd,1e6)

def calc_cell_volume(xb,yb,zb):
    '''Given the rectilinear coordinates at cell boundaries, calculate the volume of each cell.

    INPUT
    -----
    :xb: rectilinear x-grid at cell boundary loctions, dimension Nx+1
    :yb: rectilinear y-grid at cell boundary loctions, dimension Ny+1
    :zb: rectilinear z-grid at cell boundary loctions, dimension Nz+1

    OUTPUT
    ------
    :dv: volume of each cell, dimension [Nz,Ny,Nx]
    '''
    
    dx = (np.roll(xb,-1)-xb) 
    dy = (np.roll(yb,-1)-yb) 
    dz = (np.roll(zb,-1)-zb)
    return dx[None,None,:-1]*dy[None,:-1,None]*dz[:-1,None,None]


def calculate_divb_lare(bx,by,bz,x,y,z):
    '''Calculate the divergence of the magnetic field
    
    INPUT
    -----
    :bx: Array of magnetic field values at x faces of lare grid, shape (nz  , ny  ,nx+1)
    :by: Array of magnetic field values at y faces of lare grid, shape (nz  , ny+1,nx  )
    :bz: Array of magnetic field values at z faces of lare grid, shape (nz+1, ny  ,nx  )
    :x: Array of cell boundary locations in the x direction, shape (nx+1)
    :y: Array of cell boundary locations in the y direction, shape (ny+1)
    :z: Array of cell boundary locations in the z direction, shape (nz+1)

    OUTPUT
    ------
    :divb: Array of the divergence of magnetic field at cell center locations, shape (nz,ny,nx)
    '''
    dx = (np.roll(x,-1)-x) 
    dy = (np.roll(y,-1)-y) 
    dz = (np.roll(z,-1)-z) 
     
    dbx = ((np.roll(bx,-1,axis=2) - bx)/dx[None,None,:])[1:,1:,:-1]
 
    dby = ((np.roll(by,-1,axis=1) - by)/dy[None,:,None])[1:,:-1,1:]
 
    dbz = ((np.roll(bz,-1,axis=0) - bz)/dz[:,None,None])[:-1,1:,1:]
 
     
    divb = dbx+dby+dbz 
         
    ## calculate electric currents: 
    #curlx = (((np.roll(bz,-1,axis=1) - bz)/dy[None,:,None])[1:,0:,0:] - ((np.roll(by,-1,axis=0) -by)/dz[:,None,None])[0:,1:,0:]) 
    #curly = (((np.roll(bx,-1,axis=0) - bx)/dz[:,None,None])[0:,0:,1:] - ((np.roll(bz,-1,axis=2) -bz)/dx[None,None,:])[1:,0:,0:]) 
    #curlz = (((np.roll(by,-1,axis=2) - by)/dx[None,None,:])[0:,1:,0:] - ((np.roll(bx,-1,axis=1) -bx)/dy[None,:,None])[0:,0:,1:]) 
    return divb

def calculate_curl_lare(bx,by,bz,x,y,z):
    '''Quick and dirty (WRONG) electric currents.  These live at cell vertices.
    
    NOTE
    ----
    The properly calculated cell- and volume-averaged currents, as used by lare to determine the vertex lorentz forces,
    are found using the calculate_currents() function.
    
    '''

    warnings.warn("This is only an approximation for the electric currents.  For numerically rigorous, see function `calculate_currents`",ValidationWarning)
    
    dx = (np.roll(x,-1)-x) 
    dy = (np.roll(y,-1)-y) 
    dz = (np.roll(z,-1)-z) 
     
    ## calculate electric currents:
    curlx = (((np.roll(bz,-1,axis=1) - bz)/dy[None,:,None])[1:,1:,1:] - ((np.roll(by,-1,axis=0) -by)/dz[:,None,None])[1:,1:,1:]) 
    curly = (((np.roll(bx,-1,axis=0) - bx)/dz[:,None,None])[1:,1:,1:] - ((np.roll(bz,-1,axis=2) -bz)/dx[None,None,:])[1:,1:,1:]) 
    curlz = (((np.roll(by,-1,axis=2) - by)/dx[None,None,:])[1:,1:,1:] - ((np.roll(bx,-1,axis=1) -bx)/dy[None,:,None])[1:,1:,1:]) 
    return curlx,curly,curlz

def calculate_currents(bxc, byc, bzc, xb, yb,zb):
    '''Calculate properly averaged electric currents at cell vertices
    
    This functions calculates the electric current density vector at cell vertices,
    as used in the LaRe fortran code.  It is found by differencing the correct
    terms in the vertex-located jacobian of the field.  The full jacobian is 
    calculated in the calculate_jacobian_vertex function.
    
    Calculation of current density requires cell-centered magnetic field 
    values and vertex-centered coordinates in order to get the averaging correct.
    Thus, if the dimensions of the field components are NX, NY, NZ, then xb has 
    NX+1 elements, and so on. 
    Cell-centered magnetic field values in lare are the arithmetic average of the 
    two opposing faces; see the function get_b_central().

    There are six terms to calculate, and they all have their own unique averages.  
    We define the Jacobian as :math:`(\nabla\mathbf{B})_{ij} = \partial_jB_i`.
    The derivatives use values of B evaluated at cell edges.
    
    Steps (See Tarr paper notes 2020-05-14): 
    1. Take as input the average magnetic field from cell face to cell center: B_F -> B_C
    2. Volume average 4 surrounding B_C to get edge values B_E
    3. Difference edges B_E to get vertex-located components of the current density.
    
    INPUTS
    -------
    :bxc: cell centered x component of the magnetic field, dimensions [Nz, Ny, Nx]
    :byc: cell centered y component of the magnetic field, dimensions [Nz, Ny, Nx]
    :bzc: cell centered z component of the magnetic field, dimensions [Nz, Ny, Nx]
    :xb: rectilinear x-grid at cell boundary locations, dimension Nx+1
    :yb: rectilinear y-grid at cell boundary locations, dimension Ny+1
    :zb: rectilinear z-grid at cell boundary locations, dimension Nz+1


    OUTPUTS
    -------
    :current: dictionary with each of the 3 components
    
    See Also
    --------
    calc_magnetic_tension_force
    calc_magnetic_pressure_force
    calculate_jacobian_vertex
    '''
    dx = (np.roll(xb,-1)-xb) 
    dy = (np.roll(yb,-1)-yb) 
    dz = (np.roll(zb,-1)-zb)

    dv = dx[None,None,:-1]*dy[None,:-1,None]*dz[:-1,None,None]

    # Jx
    edge = volume_average_yedge(bzc,dv)
    dbzdy = (np.roll(edge,-1,axis=1)-edge)/(1./2*(dy[:-1]+dy[1:]))[None,:,None]
    edge = volume_average_zedge(byc,dv)                                   
    dbydz = (np.roll(edge,-1,axis=0)-edge)/(1./2*(dz[:-1]+dz[1:]))[:,None,None]
    jx = dbzdy-dbydz

    # Jy
    edge = volume_average_zedge(bxc,dv)
    dbxdz = (np.roll(edge,-1,axis=0)-edge)/(1./2*(dz[:-1]+dz[1:]))[:,None,None]
    edge = volume_average_xedge(bzc,dv)
    dbzdx = (np.roll(edge,-1,axis=2)-edge)/(1./2*(dx[:-1]+dx[1:]))[None,None,:]
    jy = dbxdz-dbzdx


    # Jz
    edge = volume_average_xedge(byc,dv)
    dbydx = (np.roll(edge,-1,axis=2)-edge)/(1./2*(dx[:-1]+dx[1:]))[None,None,:]
    edge = volume_average_yedge(bxc,dv)
    dbxdy = (np.roll(edge,-1,axis=1)-edge)/(1./2*(dy[:-1]+dy[1:]))[None,:,None]
    jz = dbydx-dbxdy
    return {'jx':jx,'jy':jy,'jz':jz}

    
def calculate_jacobian_vertex(bxc,byc,bzc, xb,yb,zb):
    '''Calculate the Jacobian of the magnetic field, defined at cell vertices.
    
    The jacobian of B_vec is needed to properly decompose the lorentz force into 
    the magnetic tension and pressure terms, and further, to determine the extent 
    to which those cancel.   The calculation requires cell-centered magnetic field 
    values and vertex-centered coordinates in order to get the averaging correct.
    Thus, if the dimensions of the field components are NX, NY, NZ, then xb has 
    NX+1 elements, and so on. 

    There are nine terms to calculate, and they all have their own unique averages.  
    We define the Jacobian as :math:`(\nabla\mathbf{B})_{ij} = \partial_jB_i`.  
    The derivatives use values of B evaluated at cell edges.
    
    Steps (See Tarr paper notes 2020-05-14): 
    1. Take as input the average magnetic field from cell face to cell center: B_F -> B_C
    2. Volume average 4 surrounding B_C to get edge values B_E
    3. Difference edges B_E to get vertex Jacobian
    
    Additional note:
    4. Volume average 8 B_C to get vertex valued B_V
    5. take the cross product to get the lorentz force.
    
    INPUTS
    -------
    :bxc: cell centered x component of the magnetic field, dimensions [Nz, Ny, Nx]
    :byc: cell centered y component of the magnetic field, dimensions [Nz, Ny, Nx]
    :bzc: cell centered z component of the magnetic field, dimensions [Nz, Ny, Nx]
    :xb: rectilinear x-grid at cell boundary locations, dimension Nx+1
    :yb: rectilinear y-grid at cell boundary locations, dimension Ny+1
    :zb: rectilinear z-grid at cell boundary locations, dimension Nz+1

    See Also
    --------
    calc_magnetic_tension_force
    calc_magnetic_pressure_force
    '''

    dx = (np.roll(xb,-1)-xb) 
    dy = (np.roll(yb,-1)-yb) 
    dz = (np.roll(zb,-1)-zb)

    dv = dx[None,None,:-1]*dy[None,:-1,None]*dz[:-1,None,None]

    # X derivatives
    edge = volume_average_xedge(bxc,dv)
    dbxdx = (np.roll(edge,-1,axis=2)-edge)/(1./2*(dx[:-1]+dx[1:]))[None,None,:]

    edge = volume_average_xedge(byc,dv)
    dbydx = (np.roll(edge,-1,axis=2)-edge)/(1./2*(dx[:-1]+dx[1:]))[None,None,:]

    edge = volume_average_xedge(bzc,dv)
    dbzdx = (np.roll(edge,-1,axis=2)-edge)/(1./2*(dx[:-1]+dx[1:]))[None,None,:]

    # Y derivatives
    edge = volume_average_yedge(bxc,dv)
    dbxdy = (np.roll(edge,-1,axis=1)-edge)/(1./2*(dy[:-1]+dy[1:]))[None,:,None]

    edge = volume_average_yedge(byc,dv)
    dbydy = (np.roll(edge,-1,axis=1)-edge)/(1./2*(dy[:-1]+dy[1:]))[None,:,None]

    edge = volume_average_yedge(bzc,dv)
    dbzdy = (np.roll(edge,-1,axis=1)-edge)/(1./2*(dy[:-1]+dy[1:]))[None,:,None]

    # Z derivatives
    edge = volume_average_zedge(bxc,dv)
    dbxdz = (np.roll(edge,-1,axis=0)-edge)/(1./2*(dz[:-1]+dz[1:]))[:,None,None]
                                                                          
    edge = volume_average_zedge(byc,dv)                                   
    dbydz = (np.roll(edge,-1,axis=0)-edge)/(1./2*(dz[:-1]+dz[1:]))[:,None,None]
                                                                          
    edge = volume_average_zedge(bzc,dv)                                   
    dbzdz = (np.roll(edge,-1,axis=0)-edge)/(1./2*(dz[:-1]+dz[1:]))[:,None,None]

    return {'dbxdx':dbxdx,'dbxdy':dbxdy,'dbxdz':dbxdz,'dbydx':dbydx,'dbydy':dbydy,'dbydz':dbydz,'dbzdx':dbzdx,'dbzdy':dbzdy,'dbzdz':dbzdz}

def calculate_B_vertex(bxc,byc,bzc, xb,yb,zb):
    '''Calculate properly averaged magnetic field at cell vertices
    
    The averaging takes place in the forward direction on the grid
    E.g., the 8 cells [k:k+2,j:j+2,i:i+2] average to the location [k+1,j+1,i+1]
    The averaging assumes periodic boundaries in each direction, so the boundary
    cells will be incorrect for non-periodic directions.
    

    INPUTS
    ------
    :bxc,byc,bzc: cell centered magnetic field variables, dimension [Nz,Ny,Nx]
    :xb: rectilinear x-grid at cell boundary loctions, dimension Nx+1

    OUTPUT
    ------
    :dict: - volume averaged magnetic field variables at cell vertices.
    

    '''
    dv = calc_cell_volume(xb,yb,zb)
    #dx = (np.roll(xb,-1)-xb) 
    #dy = (np.roll(yb,-1)-yb) 
    #dz = (np.roll(zb,-1)-zb)
    #dv = dx[None,None,:-1]*dy[None,:-1,None]*dz[:-1,None,None]

    bxv = volume_average_vertex(bxc,dv)
    byv = volume_average_vertex(byc,dv)
    bzv = volume_average_vertex(bzc,dv)
    return {'bxv':bxv,'byv':byv,'bzv':bzv}

def calc_grad_Bsquared(bxv,byv,bzv,jac):
    '''
    Given the magnetic field and jacobian evaluated at vertices, calc the normal vector and the curvature.

    Gah...not quite.  I need to calculate the jacobian of the normalized field not the field itself!
    '''

    btot = np.sqrt(bxv**2+byv**2+bzv**2)
    ddsbx = (bxv*dbxdx + byv*dbxdy + bzv+dbxdz)/btot
    ddsby = (bxv*dbydx + byv*dbydy + bzv+dbydz)/btot
    ddsbz = (bxv*dbzdx + byv*dbzdy + bzv+dbzdz)/btot

    kappa = np.sqrt(ddsbx**2+ddsby**2+ddsbz**2)

def calc_magnetic_tension_force(bxc,byc,bzc, xb,yb,zb):
    '''Calculate the components of magnetic tension.

    The magnetic tension :math:`\mathbf{f}_t` is given by

    .. math::
       \mathbf{f}^{(t)} = (\mathbf{B}\cdot\nabla)\mathbf{B}

       f^{(t)}_{i} = B_j \partial_j B_i - b_i b_j B_k\partial_jB_k
    
    '''

    jac = calculate_jacobian_vertex(bxc,byc,bzc, xb,yb,zb)
    dv = calc_cell_volume(xb,yb,zb)

    bxv = volume_average_vertex(bxc,dv)
    byv = volume_average_vertex(byc,dv)
    bzv = volume_average_vertex(bzc,dv)
    
    # x component
    tx = bxv*jac['dbxdx'] + byv*jac['dbxdy'] + bzv*jac['dbxdz']
    # y component
    ty = bxv*jac['dbydx'] + byv*jac['dbydy'] + bzv*jac['dbydz']
    # z component
    tz = bxv*jac['dbzdx'] + byv*jac['dbzdy'] + bzv*jac['dbzdz']

    # now subtract off the component along the field.
    # calculate this using the double summation, which is \bhat\cdot(tx,ty,tz)
    btot = np.sqrt(bxv**2+byv**2+bzv**2)
    dbl_sum = (bxv*tx + byv*ty + bzv*tz)/btot

    return {'tx':tx-bxv/btot*dbl_sum,'ty':ty-byv/btot*dbl_sum,'tz':tz-bzv/btot*dbl_sum}


def calc_magnetic_pressure_force(bxc,byc,bzc,xb,yb,zb):
    '''Calculate the components of magnetic tension.

    The magnetic tension :math:`\mathbf{f}_p` is given by

    .. math::
       \mathbf{f}^{(p)} = -\nabla_\perp B^2/2

       f^{(p)}_{i} = -B_j \partial_i B_j + b_i b_j B_k\partial_jB_k
    
    '''
    
    jac = calculate_jacobian_vertex(bxc,byc,bzc, xb,yb,zb)
    dv = calc_cell_volume(xb,yb,zb)

    bxv = volume_average_vertex(bxc,dv)
    byv = volume_average_vertex(byc,dv)
    bzv = volume_average_vertex(bzc,dv)
    
    # x component
    px = bxv*jac['dbxdx'] + byv*jac['dbydx'] + bzv*jac['dbzdx']
    # y component
    py = bxv*jac['dbxdy'] + byv*jac['dbydy'] + bzv*jac['dbzdy']
    # z component
    pz = bxv*jac['dbxdz'] + byv*jac['dbydz'] + bzv*jac['dbzdz']

    # Now subtract off the component along the field.
    # calculate this using the double summation, which is \bhat\cdot(tx,ty,tz)
    # Note that the total summation is the same as for the tension calculation,
    # but here we've reversed the summation order
    btot = np.sqrt(bxv**2+byv**2+bzv**2)
    dbl_sum = (bxv*px + byv*py + bzv*pz)/btot

    return {'px':-px + bxv/btot*dbl_sum,'py':-py+ byv/btot*dbl_sum,'pz':-pz+ bzv/btot*dbl_sum}


def lorentz_force_balance_anny():
    '''Lorentz force self balancing metric.
    
    Following Malanushenko+ ApJ, 783, 102, doi://10.1088/0004-637X/783/2/102.
    Calculate magnetic pressure f^p and magnetic tension f^t at cell vertices.
    Return the self-balancing parameter :math:`0<\\xi<1`, where the range is given by
    the triangle inequality.

    .. math::
        \\xi = \frac{|f^p + f^t|}{|f^p| + |f^t|}

    Returns
    -------
    xi : numpy.ndarray
    '''
    
    bcen = lare.get_b_central() # order: bx, by, bz
    f_pressure = lare.calc_magnetic_pressure_force(bcen[0],bcen[1],bcen[2],dat['x'],dat['y'],dat['z'])
    f_tension = lare.calc_magnetic_tension_force(bcen[0],bcen[1],bcen[2],dat['x'],dat['y'],dat['z'])

    loren_total = np.sqrt((f_pressure['px'] + f_tension['tx'])**2 +
                          (f_pressure['py'] + f_tension['ty'])**2 + 
                          (f_pressure['pz'] + f_tension['tz'])**2)

    press_tot = np.sqrt(f_pressure['px']**2 + f_pressure['py']**2+ f_pressure['pz']**2)
    tens_tot = np.sqrt(f_tension['tx']**2 + f_tension['ty']**2+ f_tension['tz']**2)
    return loren_total/(press_tot + tens_tot)


def calc_normal_direction(bxv,byv,bzv,jac):
    '''
    Given the magnetic field and jacobian evaluated at vertices, the normal vector and the curvature.

    Gah...not quite.  I need to calculate the jacobian of the normalized field, not the field itself!
    '''

    btot = np.sqrt(bxv**2+byv**2+bzv**2)
    ddsbx = (bxv*dbxdx + byv*dbxdy + bzv+dbxdz)/btot
    ddsby = (bxv*dbydx + byv*dbydy + bzv+dbydz)/btot
    ddsbz = (bxv*dbzdx + byv*dbzdy + bzv+dbzdz)/btot

    kappa = np.sqrt(ddsbx**2+ddsby**2+ddsbz**2)
    
def volume_average_vertex(var,vol):
    '''
    Average a cell centered variable to cell vertex location.
    
    The averaging takes place in the forward direction on the grid
    E.g., the 8 cells [k:k+2,j:j+2,i:i+2] average to the location [k+1,j+1,i+1]
    The averaging assumes periodic boundaries in each direction, so the boundary
    cells will be incorrect for non-periodic directions.
    

    INPUTS
    ------
    var : cell centered variable, dimension [Nz,Ny,Nx]
    vol : volume of each cell, dimension [Nz,Ny,Nx]

    '''

    return (var*vol +
             np.roll(var*vol,-1,axis=1) +
             np.roll(var*vol,-1,axis=0) +
             np.roll(var*vol,-1,axis=(0,1)) +
             np.roll(var*vol,-1,axis=2) +
             np.roll(var*vol,-1,axis=(1,2)) +
             np.roll(var*vol,-1,axis=(0,2)) +
             np.roll(var*vol,-1,axis=(0,1,2)))/(vol +
                                                np.roll(vol,-1,axis=1) +
                                                np.roll(vol,-1,axis=0) +
                                                np.roll(vol,-1,axis=(0,1)) +
                                                np.roll(vol,-1,axis=2) +
                                                np.roll(vol,-1,axis=(1,2)) +
                                                np.roll(vol,-1,axis=(0,2)) +
                                                np.roll(vol,-1,axis=(0,1,2)))

def volume_average_xedge(var, vol):
    '''
    Calculate the x-edge-centered volume average of a cell centered variable.
    '''

    return (var*vol + np.roll(var*vol,-1,axis=1)+np.roll(var*vol,-1,axis=0)+np.roll(var*vol,-1,axis=(0,1)))/(vol + np.roll(vol,-1,axis=1)+np.roll(vol,-1,axis=0)+np.roll(vol,-1,axis=(0,1)))

def volume_average_yedge(var, vol):
    '''
    Calculate the y-edge-centered volume average of a cell centered variable.
    '''

    return (var*vol + np.roll(var*vol,-1,axis=2)+np.roll(var*vol,-1,axis=0)+np.roll(var*vol,-1,axis=(0,2)))/(vol + np.roll(vol,-1,axis=2)+np.roll(vol,-1,axis=0)+np.roll(vol,-1,axis=(0,2)))

def volume_average_zedge(var, vol):
    '''
    Calculate the z-edge-centered volume average of a cell centered variable.
    '''

    return (var*vol + np.roll(var*vol,-1,axis=2)+np.roll(var*vol,-1,axis=1)+np.roll(var*vol,-1,axis=(1,2)))/(vol + np.roll(vol,-1,axis=2)+np.roll(vol,-1,axis=1)+np.roll(vol,-1,axis=(1,2)))


if __name__ =="__main__":
    '''
    Memory-safe default behavior.  Just get the grid and the all the variable names.
    '''
    filename = './0000.cfd'
    read_lare_cfd3d(filename=filename,getfields=('grid',))
       
